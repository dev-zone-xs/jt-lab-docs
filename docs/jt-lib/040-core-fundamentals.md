---
id: core-fundamentals
title: Основы и ядро (Core)
sidebar_label: Основы и ядро
---

# Основы и ядро (Core)

Ядро JT-LIB представляет собой фундаментальные компоненты, на которых построена вся библиотека. Эти компоненты обеспечивают базовую функциональность для всех остальных частей системы.


## BaseObject - Базовый класс для всех объектов

**BaseObject** является корневым классом для всех объектов в JT-LIB. Он предоставляет базовую функциональность для управления жизненным циклом объектов.

### Основные возможности

- **Уникальная идентификация** - каждый объект получает уникальный ID
- **Управление жизненным циклом** - создание, уничтожение, восстановление
- **Система дочерних объектов** - иерархическая структура объектов
- **Обработка ошибок** - встроенная система логирования ошибок
- **Подписка на события** - автоматическая отписка при уничтожении

### Ключевые методы

- **`id: string`** - уникальный идентификатор объекта
- **`addChild(child: BaseObject): void`** - добавление дочернего объекта для корректного управления жизненным циклом
- **`async call(functionName: string, data?: any): Promise<any>`** - вызов метода по имени
- **`destroy(): void`** - корректное уничтожение объекта и всех дочерних
- **`error(msg: string | Error, context?: any): void`** - обработка ошибок с контекстом

### Система управления жизненным циклом

**BaseObject** автоматически регистрируется в глобальном хранилище `globals` при создании. Это обеспечивает централизованное управление всеми объектами в системе.

**Важно понимать**: В TypeScript нельзя просто "уничтожить" объект - у него остаются активные подписки на события, которые могут вызывать ошибки. Поэтому для корректного завершения работы объекта необходимо вызывать метод `destroy()`.

**Функция `addChild()`** служит для того, чтобы при уничтожении родительского объекта корректно отписывались от всех подписок все дочерние объекты. Это предотвращает утечки памяти и некорректное поведение системы.

## Globals - Глобальное состояние системы

**Globals** управляет глобальным состоянием приложения и предоставляет доступ ко всем основным сервисам.

### Основные сервисы

- **Script** - текущий торговый скрипт (ранее Strategy)
- **Events** - система событий (EventEmitter)
- **Triggers** - сервис триггеров с автоматическим хранением
- **Report** - система отчетности
- **Storage** - хранение данных
- **CandlesBufferService** - управление свечными данными
- **Indicators** - технические индикаторы

### Ключевые свойства

- **`script: BaseScript`** - текущий торговый скрипт (ранее strategy)
- **`events: EventEmitter`** - система событий
- **`triggers: TriggerService`** - сервис триггеров с автоматическим хранением
- **`report: Report`** - система отчетности
- **`storage: Storage`** - хранение данных
- **`candlesBufferService: CandlesBufferService`** - управление свечными данными
- **`indicators: Indicators`** - технические индикаторы
- **`isTradeAllowed: boolean`** - разрешение на торговые операции
- **`_objects: Record<string, BaseObject>`** - глобальное хранилище всех объектов
- **`userData: Map<string, any>`** - пользовательские данные
- **`IS_NO_LOGS: number`** - управление логированием 
- **`isDebug: boolean`** - режим отладки

### Централизованное управление объектами

**Globals** обеспечивает централизованное управление всеми объектами в системе. При создании любого объекта, наследующего от `BaseObject`, он автоматически регистрируется в `globals._objects` с уникальным идентификатором.

Это позволяет системе отслеживать все активные объекты, управлять их жизненным циклом и обеспечивать корректное освобождение ресурсов при завершении работы.

## Base - Утилиты для работы с аргументами

**Base** предоставляет набор утилитарных функций для работы с глобальной переменной `ARGS`, которая содержит параметры, передаваемые при запуске скрипта из JT-Trader.

**Важно понимать**: Все функции `getArg*` работают с глобальной переменной `ARGS`, которая автоматически заполняется параметрами, указанными пользователем в интерфейсе JT-Trader при запуске торговой стратегии.

### Основные функции

#### uniqueId()
Генерирует уникальный идентификатор заданной длины. По умолчанию создает ID длиной 4 символа, но можно указать произвольную длину.

#### getArgNumber()
Безопасно извлекает числовой аргумент из глобальной переменной `ARGS` с проверкой типов. Поддерживает значения по умолчанию и обязательные аргументы. Автоматически проверяет на дублирование аргументов в сценарии - если один и тот же параметр передан дважды, функция выбросит ошибку.

#### getArgString()
Безопасно извлекает строковый аргумент из глобальной переменной `ARGS`. Обеспечивает корректную обработку строковых значений с поддержкой обязательных аргументов. Если обязательный аргумент не найден, функция выбросит ошибку с указанием названия параметра.

#### getArgBoolean()
Безопасно извлекает булевый аргумент из глобальной переменной `ARGS`. Поддерживает как булевые, так и строковые значения ('true'/'false'). Автоматически конвертирует строки в соответствующие булевые значения. Если обязательный аргумент не найден, функция выбросит ошибку.

#### isIterable()
Проверяет, является ли объект итерируемым. Распознает массивы, Map, Set и другие итерируемые структуры данных.

### Как работает система ARGS в JT-Trader

При запуске торговой стратегии в JT-Trader создается глобальная переменная `ARGS`, которая содержит все параметры, переданные при запуске. Система поддерживает два режима:

**Режим Runtime (торговля в реальном времени):**
```typescript
ARGS = {
  connectionName: 'Binance',
  symbols: 'BTC/USDT,ETH/USDT',
  amount: 0.001,
  stopLoss: 45000,
  takeProfit: 55000,
  isDebug: true
}
```

**Режим Tester (тестирование на исторических данных):**
```typescript
ARGS = {
  connectionName: 'Binance',
  symbols: 'BTC/USDT,ETH/USDT',
  symbol: 'BTC/USDT',
  // Параметры тестера
  start: '2021-01',
  end: '2021-12',
  startDate: new Date('2021-01-01T00:00:00.000Z'),
  endDate: new Date('2021-12-31T23:59:59.999Z'),
  timeframe: '1h',
  optimizerIteration: 1,
  makerFee: 0.001,
  takerFee: 0.001,
  marketOrderSpread: 0.0001,
  balance: 10000,
  leverage: 1,
  // Пользовательские параметры
  amount: 0.001,
  stopLoss: 45000,
  takeProfit: 55000,
  isDebug: true
}
```

**Использование в стратегии:**
```typescript
const symbol = getArgString('symbol', 'ETH/USDT');        // 'BTC/USDT'
const amount = getArgNumber('amount', 0.001, true);      // 0.001 (обязательный)
const stopLoss = getArgNumber('stopLoss', 0);            // 45000
const isDebug = getArgBoolean('isDebug', false);         // true
```

## Storage - Система хранения данных

**Storage** обеспечивает персистентное хранение объектов и их состояния между запусками стратегии.

### Основные возможности

- **Кэширование объектов** - хранение ссылок на объекты
- **Сохранение состояния** - автоматическое сохранение свойств объектов
- **Восстановление состояния** - восстановление объектов при перезапуске
- **Поддержка сложных типов** - Array, Date, Map, Set, RegExp
- **Отладка** - детальное логирование операций

### Ключевые методы

- **`addObject(key: string, obj: BaseObject | object, props?: string[]): void`** - добавление объекта для отслеживания с указанием свойств для сохранения
- **`removeObject(key: string): void`** - удаление объекта из системы отслеживания
- **`saveState(): Promise<void>`** - сохранение состояния всех отслеживаемых объектов
- **`loadState(): Promise<void>`** - загрузка сохраненного состояния
- **`reStoreState(key: string, obj: object): void`** - восстановление состояния конкретного объекта

### Поддерживаемые типы данных

Storage автоматически обрабатывает и сохраняет следующие типы данных:
- **Array** - массивы
- **Date** - даты и время
- **Map** - Map объекты
- **Set** - Set объекты
- **Object** - обычные объекты
- **RegExp** - регулярные выражения

### Автоматическое управление состоянием

При добавлении объекта в Storage система автоматически отслеживает изменения в указанных свойствах и сохраняет их состояние. При перезапуске стратегии все объекты восстанавливаются с сохраненными значениями.

## Log - Система логирования и отладки

**Log** предоставляет комплексную систему логирования для отладки и мониторинга работы стратегий.

### Уровни логирования

#### log()
Основной уровень логирования для информационных сообщений. Используется для записи важных событий в работе стратегии.

#### trace()
Детальное логирование для отладки. Предоставляет подробную информацию о выполнении операций.

#### warning()
Предупреждения, которые не останавливают выполнение стратегии, но требуют внимания разработчика.

#### error()
Ошибки с детальным контекстом и стеком вызовов. Автоматически увеличивает счетчик ошибок и может привести к остановке стратегии.

#### debug()
Отладочная информация, доступная только в debug режиме. В тестере отключается для повышения производительности.

### Настройки логирования

- **`ARGS.isNoLogs = 1`** - полное отключение логирования
- **`ARGS.isDebug = true`** - включение debug режима
- **`ARGS.isDebugStorage = true`** - детальное логирование операций storage

### Автоматическое управление ошибками

Система автоматически отслеживает количество ошибок и может остановить стратегию при превышении лимитов:
- **В тестере**: остановка после 20 ошибок
- **В реальном времени**: остановка после 10 ошибок
- **Автоматический сброс**: счетчик ошибок сбрасывается каждый час



### Архитектурные улучшения
- **Упрощение доступа к скрипту** - более интуитивный API через `globals.script`
- **Улучшенная персистентность** - триггеры сохраняют свое состояние между запусками
- **Оптимизация производительности** - уменьшено количество ненужных операций

## Взаимодействие компонентов

Все компоненты ядра тесно связаны между собой и образуют единую экосистему:

**BaseObject** использует `globals` для автоматической регистрации в глобальном хранилище. Это обеспечивает централизованное управление всеми объектами.

**Storage** наследуется от `BaseObject`, получая все возможности по управлению жизненным циклом и автоматической регистрации в системе.

**Log** использует `globals` для управления настройками логирования и доступа к глобальным параметрам.

**Base** предоставляет утилиты для всех компонентов, обеспечивая единообразную работу с аргументами и базовыми операциями.

Такая архитектура обеспечивает надежное управление ресурсами, предотвращает утечки памяти и гарантирует корректное завершение работы всех компонентов системы.


